#pragma once
#include <iostream>
#include <conio.h>
#include <string>
#include <cstdlib>
#include <ctime>
#include <time.h>

using namespace std;
typedef unsigned long long INT_64;
//структура узла дерева (иерархической PKI)
struct Node {
	//значение дерева
    string value;
	//ключ дерева
	INT_64 key;
	//правый сын
	Node *right;
	//левый сын
	Node *left;
};
//вставка узла в дерево (иерархическую PKI)
//value-вставляемое значение, Tree-дерево (иерархическая PKI)
void add_BST(INT_64 key, string value, Node *&Tree) {
	//добавление нового узла в пустое дерево (иерархическую PKI)
	if (Tree == NULL) {
		//созданние узла в дереве (иерархической PKI)
		Tree = new Node;
		//присваение значению
		Tree->value = value;
		//присваиваем ключ
		Tree->key = key;
		//установка левого сына равного нулю
		Tree->left = NULL;
		//уставнока правого сына равного нулю
		Tree->right = NULL;
		return;
	}
	//дерево(иерархическая PKI) не пустое
	Node *p,*n = Tree; //переменные для прогана по дереву (иерархической PKI)
	if (Tree != NULL) {
		//прогон по всем узлам в дереве (иерархической PKI)
		while (n) {
			p = n;
			//если введенное key больше чем в узле дерева (иерархической PKI) p->key
			if (p->key < key) {
				//переход на правый узел
				n = p->right;
			}
			//если введенное key меньше чем в узле дерева (иерархической PKI) p->key
			else if (p->key > key) {
				//переход на левый узел
				n= p->left;
			}
			//дошли до нужного места вставки
			else return;
		}
		//если значение узла после которого надо вставить новый узел меньше введенного значения key
		if (p->key < key) {
			//создаем новый узел с введенным value как правый узел относительно узла после которого мы должны создать новый
			p->right = new Node;
			//присваиваем новому узлу значение
			p->right->value = value;
			//установка левого сына равного нулю
			p->right->left = NULL;
			//установка левого сына равного нулю
			p->right->right = NULL;
			//присваиваем новому узлу ключ
			p->right->key = key;
		}
		//если значение узла после которого надо вставить новый узел больше введенного значения key
		else if (p->key > key) {
			//создаем новый узел с введенным value как левый узел относительно узла после которого мы должны создать новый
			p->left = new Node;
			//присваиваем новому узлу значение
			p->left->value = value;
			//установка левого сына равного нулю
			p->left->left = NULL;
			//установка левого сына равного нулю
			p->left->right = NULL;
			//присваиваем новому узлу ключ
			p->left->key = key;
		}
	}
}
//распечатка дерева (иерархической PKI) (рекурсивная реализация)
//r-дерево (иерархическая PKI), level-уровни для распечатки
void _Show(Node *r, int level) {
	//проверка дерева (иерархической PKI) на пустоту
	if (r == NULL) return;
	//идем в правые сыновья(узлы)
	_Show(r->right, level + 1);
	//сдвиг для определения места узла
	for (int i = 0; i<3 * level; i++) cout << " ";
	//вывод значения узла
	cout << r->value << endl;
	//идем в левые сыновья (узлы)
	_Show(r->left, level + 1);
}
//главная функция распечатки
//tree-дерево (иерархическая PKI)
void print_BST(Node *tree) {
	//проверка на пустоту дерева
	if (tree == NULL) {
		cout << "Дерево пустое." << endl;
		return;
	}
	//рекурсивная распечатка дерева
	_Show(tree, 0);
}
//очитска дерева (иерархическая PKI)(рекурсивная реализация)
//tree-дерево (иерархическая PKI)
void drop(Node *&tree) {
	//удаление не пустого дерева (иерархической PKI)
	if (tree != NULL) {
		//по левым узлам
		drop(tree->left);
		//по правым узлам
		drop(tree->right);
		//удаление
		delete tree;
		tree = NULL;
	}
}
//булевская функция очитски дерева (иерархической PKI), которая показывает: дерево (иерархическая PKI) пустое (true), дерево (иерархическая PKI) было удалено после очистки дерева (иерархической PKI) (false)
//tree-дерево (иерархическая PKI)
bool drop_BST(Node *&tree) {
	//проверка на пустоту дерева (иерархической PKI)
	if (tree == NULL) {
		return true;
	}
	else {
		//очистка дерева в случае если дерево (иерархическая PKI) не пустое
		drop(tree);
		if (tree == NULL) return false;
	}
}
//удаление узла с определенным значением из дерева (иерархической PKI), булевская функция: если удалено значение (true)
//tree-дерево (иерархическая PKI), key-ключ
bool delete_BST(Node *&Tree, INT_64 key) {
	Node *t = Tree, *pred = NULL, *x = NULL, *t0 = NULL;//pred-поиска родительского узла относительно узлов
	//ищем место в котором находится удаляемый узел и ищем его родительский узел
	//дерево не должно быть пустое и до тех пор пока значение в узле дерева t->value неравно заданному значению для удаления
	while (t != NULL && t->key != key) 
	{
		//ищем родельский узел удаляемого узла
		pred = t;
		//  если удаляемое значение value меньше значения в узле, то смещаемся по дереву (иерархической PKI) влево иначе вправо
		if (key < t->key) t = t->left;
		else t = t->right;
	}
	//если нет узла, то выводим false-нельзя удалить
	if (t == NULL) return false; 
	//проверяем на наличие сыновей правый и левых данного узла
	if (t->left != NULL && t->right != NULL)
	{
		//запоминаем удаляемый узел
		t0 = t;
		//ищем родительский узел для узла
		pred = t;
		//идем в правые узлы
		t = t->right;
		//ищем в левом самый наименьший узел
		while (t->left != NULL)
		{
			//ищем родительский узел
			pred = t;
			//сдвигаемся влево
			t = t->left;
		}
		//если есть только правый сын, запоминаем его в буферной переменной
		x = t->right;
	}
	else
	{ 
		//нет смысла запоминать удаляемый узел так как у него макс только 1 сын либо правый либо левый, либо их нет
		t0 = NULL;
		//если нет сновей, то лист
		if (t->left == NULL && t->right == NULL) x = NULL;	//Лист
		//если нет левого сына, то запоминаем в буферной переменной его правого сына
		else if (t->left == NULL) x = t->right;
		//если нет правого сына, то запоминаем в буферной переменной его левого сына
		else if (t->right == NULL) x = t->left;
	}
	//если удаляем голову, то значение присваем из буферной переменной
	if (pred == NULL) Tree = x;
	else
	{
		//если зачнеие в узле t->value меньше значение в родительском узле pred->value, то к левому сыны родительского узла pred->left присваем данные из буфферной переменной x, иначе правому сыну
		if (t->value<pred->value) pred->left = x;
		else pred->right = x;
	}
	//если удаляемый узел не пустой, то присавиваем ему значение наименьшего
	if (t0 != NULL)
	{
		t0->value = t->value;
	}
	delete t; // удаляем старый узел
	return true;//удаление прошло успешно
}
//поиска узла по определенному значению в дереве (иерархической PKI), булевская функция: если значение найдено (true)
//tree-дерево (иерархическая PKI), key-ключ
bool search_BST(Node *tree, INT_64 key) {
	//проверка дерева (иерархической PKI) на пустоту
	if (tree == NULL) return false;
	//переменные для прогана по дереву (иерархической PKI)
	Node *p, *n = tree;
	//прогон по всем узлам в дереве (иерархической PKI)
	while (n) {
		p = n;
		//если введенное value больше чем в узле дерева (иерархической PKI) p->key
		if (p->key < key) {
			//переход на правый узел
			n = p->right;
		}
		//если введенное value меньше чем в узле дерева (иерархической PKI) p->key
		else if (p->key > key) {
			//переход на левый узел
			n = p->left;
		}
		//если введенное value равно значению в узле дерева (иерархической PKI) p->key, то нашли данное значение
		else if (p->key == key) return true;
	}
}
void _Show_DFS(Node *r, INT_64 key) {
	//проверка дерева (иерархической PKI) на пустоту
	if (r == NULL) return;
	if (r->key < key) {
		//вывод значения узла
		cout << r->value << " ";
		//идем в правые сыновья(узлы)
		_Show_DFS(r->right, key);
	}
	else {
		//вывод значения узла
		cout << r->value << " ";
		//идем в левые сыновья (узлы)
		_Show_DFS(r->left, key);
	}
}
//главная функция обход в глубину
//tree-дерево (иерархическая PKI)
void DFS_BST(Node *tree, INT_64 key) {
	//проверка на пустоту дерева
	if (tree == NULL) {
		cout << "Дерево (иерархическая PKI) пустое." << endl;
		return;
	}
	if (search_BST(tree, key) == true) {
		//рекурсивная распечатка дерева (иерархическая PKI)
		_Show_DFS(tree, key);
		cout << endl;
	}
	else
		cout << "Нет такого элемента в дереве (иерархической PKI) " << endl;
}

